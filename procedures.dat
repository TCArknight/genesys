<?xml version="1.0" encoding="ISO-8859-1"?>

<!-- This file contains the definitions of assorted procedures that are used
      throughout the data files. Since procedures are typically called from multiple
      places, it usually makes sense to put them all in one central location where
      you can always find them instead of having them littered throughout the data
      files and hard to locate when you need to refer to them.
  -->

<document signature="Hero Lab Data">


<!-- ##################
      The following procedures are generic and used in various places
     ##################
-->

  <!-- Procedure Money
        Format monetary values for appropriate display. The value to be formatted
        is passed in via the "moneyvalue" variable. The formatted string is returned
        in the "money" variable. If the money is an integral value, no decimals
        are appended. Otherwise, the value is rounded to two decimals and output
        with two decimals, so "$1.5" actually looks like "$1.50".

        Outbound parameter: money
        Inbound parameter:  moneyvalue
  -->
  <procedure id="Money" scripttype="none"><![CDATA[
    ~declare variables that are used to communicate with our caller
    var moneyvalue as number
    var money as string

    ~invoke the MoneyBare procedure to format the value
    call MoneyBare

    ~prepend a "$" on the value
    money = "$" & money
    ]]></procedure>


  <!-- Procedure MoneyBare
        Handles the formatting of the money value without prepending the currency
        symbol, which is useful in situations where you just want the raw value.

        Outbound parameter: money
        Inbound parameter:  moneyvalue
  -->
  <procedure id="MoneyBare" scripttype="none"><![CDATA[
    ~declare variables that are used to communicate with our caller
    var moneyvalue as number
    var money as string

    ~format the value properly for display as currency
    if (moneyvalue = int(moneyvalue)) then
      money = moneyvalue
    else
      money = decimals(moneyvalue,2)
      endif
    ]]></procedure>


<!-- ##################
      The following procedures are used in conjuction with description and mouse-info scripts
     ##################
-->

  <!-- Procedure Prereqs
        Generate a list of all failed pre-requisites for the pick/thing that is the
        current script context, with one failed prereq to a line. We do this for use
        within all "info" scripts, so we cannot use any special symbols. Instead, we
        put the results into the "prereqs" text variable that the caller must also
        declare, allowing the caller to extract the results synthesized below. The
        caller can also specify that we always check our prereqs against the hero
        instead of the pick/thing's container, which is done by setting the
        "use_hero" variable to a non-zero value.

        Outbound parameter: prereqs
        Inbound parameter:  use_hero
  -->
  <procedure id="Prereqs" context="info"><![CDATA[
    ~declare variables that are used to communicate with our caller
    var prereqs as string
    var use_hero as number

    ~declare variables that are used internally
    var v_req_text as string
    var v_reqnum as number
    var v_req as string
    var v_i as number
    var v_is_first as number
    var v_result as number

    ~get the number of prereqs for the pick/thing and reset the text to empty
    v_reqnum = prereqnum - 1
    prereqs = ""

    ~iterate through all of our prereqs and append any that aren't satisfied
    for v_i = 0 to v_reqnum

      ~get the message for the next prereq
      if (use_hero <> 0) then
        v_req = prereqmsg[v_i,hero]
      else
        v_req = prereqmsg[v_i]
        endif

      ~if the message is non-empty, it's been failed, so append it
      prereqs = splice(prereqs,v_req,"{br}")
      next

    ~if we have any failed prerequisites, wrap them in red to highlight them
    if (v_is_first = 0) then
      prereqs = "{text clrwarning}" & prereqs & "{text clrreset}{br}{br}"
      endif
    ]]></procedure>


  <!-- Procedure MouseInfo
        Generate full details for the pick/thing that is the current script context.
        The details include the name and are intended for use within a mouseinfo
        script. As with the "Prereqs" script above, we want this procedure to work
        from any "info" script, so we cannot use special symbols. The results are
        synthesized into a variable named "mouseinfo" that the caller must also
        declare, allowing the caller to access the results upon return. The caller
        can request the inclusion of failed prereqs in the details by setting the
        "isprereq" variable to non-zero. Failed prereqs are typically only included
        for things but can be included for picks.

        Outbound parameter: mouseinfo
        Inbound parameter:  isprereq
  -->
  <procedure id="MouseInfo" context="info"><![CDATA[
    ~declare variables that are used to communicate with our caller
    var mouseinfo as string

    ~declare variables that are used internally
    var v_name as string

    ~get the item name; if this is a pick, amend the name with our gear quantity
    v_name = field[name].text
    if (ispick <> 0) then
      ~if this is gear with a quantity of more than one, append it to the name
      if (isgear <> 0) then
        if (stackable <> 0) then
          if (field[stackQty].value > 1) then
            v_name &= " (x" & field[stackQty].text & ")"
            endif
          endif
        endif
      endif

    ~start our info text with the centered name and switch to left-justified text
    mouseinfo = "{b}" & v_name & "{/b}{br}{br}{align left}"

    ~get the rest of the details for the item using the normal description procedure;
    ~we call another procedure, so we must declare the variables it uses to pass in
    ~our state and return the synthesized text, then pull the results out of the
    ~variable for our use
    var descript as string
    call Descript
    mouseinfo &= descript
    ]]></procedure>


  <!-- Procedure Descript
        Generate full details for the pick/thing that is the current script context.
        The details exclude the name and are intended for use within a description
        script. As with the "Prereqs" script above, we want this procedure to work
        from any "info" script, so we cannot use special symbols. The results are
        synthesized into a variable named "descript" that the caller must also
        declare, allowing the caller to access the results upon return. The caller
        can request the inclusion of failed prereqs in the details by setting the
        "isprereq" variable to non-zero. Failed prereqs are typically only included
        for things but can be included for picks.

        Outbound parameter: descript
        Inbound parameter:  isprereq
  -->
  <procedure id="Descript" context="info"><![CDATA[
    ~declare variables that are used to communicate with our caller
    var descript as string
    var isprereq as number

    ~declare variables that are used by called procedures
    var iteminfo as string

    ~if this is a show-only thing, just output any description text and we're done
    if (tagis[thing.showonly] <> 0) then
      descript = field[descript].text
      done
      endif

    ~we start our details text with nothing
    descript = ""

    ~if requested or renderend for a thing, append any failed prereq details
    if (isprereq + !ispick <> 0) then
      var prereqs as string
      call Prereqs
      descript &= prereqs
      endif

    ~if component is a skill, display if it is a career skill or not.
    if (tagis[component.Skill] <> 0) then
      if (tagis[SkillType.CareerSkill] <> 0) then
        descript &= "{i}Career Skill{/i}" & "{br}"
        endif 
      endif
    ~based on the nature of the item, synthesize the appropriate details that are
    ~specific to the particular item type
    iteminfo = ""
	
    if (tagis[component.WeapRange] <> 0) then
      call InfoRange
    elseif (tagis[component.WeapMelee] <> 0) then
      call InfoMelee
    elseif (tagis[component.Defense] <> 0) then
      call InfoDef
    elseif (tagis[component.Advance] <> 0) then
      call InfoAdv
      endif
    
	call InfoQualities
	
    ~if this is a piece of gear, append proper info to the item-specific details
    if (tagis[component.Gear] <> 0) then

      ~if this is a thing, append the cost
      ~if (ispick = 0) then
      ~  iteminfo &= "Cost: " & field[grCost].text & "{br}"
      ~  endif

      ~append the item's encumbrance
      iteminfo &= "Encumbrance: "
      if (field[gearWeight].value > 0) then
        iteminfo &= field[gearWeight].text
      else
        iteminfo &= chr(150)
        endif
      iteminfo &= "{br}"
	  
	  ~This provides the description of the modification properties of an item
      if (tagis[ItemMod.ItemModHelper] <> 0) then
        call InfoMods
        endif

	  iteminfo &= "Cost: " & field[grTotalCost].text & "{br}"
	  
      endif

    ~append our item-specific info to the synthesized details text
    descript &= iteminfo

    ~append the description of the item
    if (empty(iteminfo) = 0) then
      descript &= "{br}"
      endif
    if (field[descript].isempty <> 0) then
      descript &= chr(150) & " no description " & chr(150)
    else
	  if (tagis[component.Gear] <> 0) then
	    descript &= field[grOutDesc].text
      else
        descript &= field[descript].text
		endif
      endif

    ~if this is gear, output any container/containee details
    if (isgear <> 0) then

      ~if we're held somewhere, append our path
      if (isgearheld <> 0) then
        descript &= "{br}{br}{b}Container{/b}: " & gearpath["->"]
        endif

      ~if we're a gear holder, append our contents
      if (isgearlist <> 0) then
        iteminfo = gearlist[", ", TRUE]
        if (empty(iteminfo) <> 0) then
          iteminfo = "None"
          endif
        descript &= "{br}{br}{b}Carries{/b}: " & iteminfo
        endif

      endif
    ]]></procedure>


  <!-- Procedure InfoWeapon
        Generate details specific to all weapons. The text is placed into the
        "iteminfo" variable for subsequent use by our caller.

        Outbound parameter: iteminfo
  -->
  <procedure id="InfoWeapon" context="info"><![CDATA[
    ~declare variables that are used to communicate with our caller
    var iteminfo as string

    ~report the weapon bonus (omitting if there is none)
    iteminfo = ""
    if (field[wpBonus].value <> 0) then
      iteminfo &= "Weapon Bonus/Penalty: "
      if (field[wpBonus].value > 0) then
        iteminfo &= "+"
        endif
      iteminfo &= field[wpBonus].text & "{br}"
      endif

    ~report the net attack rating of the weapon
    iteminfo &= "Skill: " & tagnames[WeaponSkill.?,","] & "{br}"

    ~report the damage rating of the weapon
    iteminfo &= "Damage: " 
	if (tagis[component.WeapMelee] <> 0) then
      iteminfo &= signed(field[wpDamage].text) 
	else
	  iteminfo &= field[wpDamage].text
	  endif
	  
	iteminfo &= "{br}"

    ~report the crit rating of the weapon
    iteminfo &= "Crit Rating: " & field[wpCrit].text & "{br}"
	
    ~report the minimum strength requirement (omitting if there is none)
    if (field[wpStrReq].value > 0) then
      iteminfo &= "Minimum Strength: " & field[wpStrReq].text & "{br}"
      endif
    ]]></procedure>


  <!-- Procedure InfoWeapSp
        Generate special abilities specific to all weapons. This is separate from
        the "InfoWeapon" procedure so that it can always be performed last. The
        text is placed into the "iteminfo" variable for subsequent use by our caller.

        Outbound parameter: iteminfo
  -->
  <procedure id="InfoWeapSp" context="info"><![CDATA[
    ~declare variables that are used to communicate with our caller
    var iteminfo as string

    ~report any special details about the weapon (omitting if there are none)
    var special as string
	var iqual as string
	
	~report the weapon as two-handed (if any)
    if (tagis[Equipment.TwoHand] <> 0) then
      special = splice(special,"Requires two hands",", ")
      endif
	
	~append the item's qualities
    iteminfo &= "Special: "
    if (empty(special) = 0) then
      iteminfo &= special
    else
      iteminfo &= chr(150)
      endif
    iteminfo &= "{br}"
	  
    ]]></procedure>

  <procedure id="InfoQualities" context="info"><![CDATA[
    ~declare variables that are used to communicate with our caller
    var iteminfo as string

    ~report any special details about the weapon (omitting if there are none)
    var special as string
	var iqual as string
	
	doneif (tagis[ItemQuality.?] = 0)
	
    iqual = tagnames[ItemQuality.?,", "]
    if (empty(iqual) = 0) then
      special = splice(special,iqual,", ")
	  endif
	
	~append the item's qualities
    iteminfo &= "Qualities: "
    if (empty(special) = 0) then
      iteminfo &= special
    else
      iteminfo &= chr(150)
      endif
    iteminfo &= "{br}"
	  
    ]]></procedure>
  <!-- Procedure InfoMelee
        Generate details specific to a melee weapon. The text is placed into the
        "iteminfo" variable for subsequent use by our caller.

        Outbound parameter: iteminfo
  -->
  <procedure id="InfoMelee" context="info"><![CDATA[
    ~declare variables that are used to communicate with our caller
    var iteminfo as string

    ~start with generic details for all weapons
    call InfoWeapon

    ~finish with generic special abilities for all weapons
    call InfoWeapSp
    ]]></procedure>


  <!-- Procedure InfoRange
        Generate details specific to a ranged weapon. The text is placed into the
        "iteminfo" variable for subsequent use by our caller.

        Outbound parameter: iteminfo
  -->
  <procedure id="InfoRange" context="info"><![CDATA[
    ~declare variables that are used to communicate with our caller
    var iteminfo as string

    ~start with generic details for all weapons
    call InfoWeapon

    ~add the range details for the weapon
    iteminfo &= "Range: " & field[wpRange].text & "{br}"

    ~finish with generic special abilities for all weapons
    call InfoWeapSp
    ]]></procedure>


  <!-- Procedure InfoDef
        Generate details specific to defensive gear, including armor and shields.
        The text is placed into the "iteminfo" variable for subsequent use by our
        caller.

        Outbound parameter: iteminfo
  -->
  <procedure id="InfoDef" context="info"><![CDATA[
    ~declare variables that are used to communicate with our caller
    var iteminfo as string

    ~add the defense rating
    iteminfo &= "Defense: " & field[defDefense].text & "{br}"
	
    ~add the soak rating
    iteminfo &= "Soak: " & signed(field[defSoak].text) & "{br}"
    
	~add the defense rating
    iteminfo &= "Defense (Melee/Ranged): " & field[defDefenseMelee].text & " / " & field[defDefenseRange].text & "{br}"

    ~report the minimum strength requirement (omitting if there is none)
    if (field[defStrReq].value > 0) then
      iteminfo &= "Minimum Strength: " & field[defStrReq].text & "{br}"
      endif

    ]]></procedure>


  <!-- Procedure InfoAdv
        Generate details specific to advances. The text is placed into the
        "iteminfo" variable for subsequent use by our caller.

        Outbound parameter: iteminfo
  -->
  <procedure id="InfoAdv" context="info"><![CDATA[
    ~declare variables that are used to communicate with our caller
    var iteminfo as string

    ~if we don't have a valid pick to operate upon, just get out, else we get errors
    doneif (ispick = 0)

    ~add any user notes
    if (gizmo.child[advDetails].field[advNotes].isempty = 0) then
      iteminfo &= "User Notes: " & gizmo.child[advDetails].field[advNotes].text & "{br}"
      endif
    ]]></procedure>


  <!-- Procedure InfoHeld
        Retrieve a summary of what container this gear is currently held within.
        Used for mouse-info scripts with equipment, with the generated text being
        assigned to the @text special symbol for the script.
  -->
  <procedure id="InfoHeld" scripttype="mouseinfo"><![CDATA[
    @text = "Held by: " & gearholder.field[name].text
    ]]></procedure>


  <!-- Procedure InfoHolder
        Retrieve a summary of what equipment is held within this gear container.
        Used for mouse-info scripts with equipment, with the generated text being
        assigned to the @text special symbol for the script.
  -->
  <procedure id="InfoHolder" scripttype="mouseinfo"><![CDATA[
    var gear as string
    gear = gearlist["; ", TRUE]
    if (empty(gear) <> 0) then
      gear = "Empty"
      endif
    @text = "{align left}This item is a container.{br}{br}Contents: " & gear
    ]]></procedure>


<!-- ##################
      The folowing procedures are used with transactions for buying and selling items
     ##################
-->


  <!-- Procedure XactSetup
        Perform setup of the transaction fields when the user is purchasing an item.
  -->
  <procedure id="XactSetup" scripttype="xactsetup"><![CDATA[
    ~start by assuming our unit cost is the cost of one item
    ~Note: If this is the purchase of a thing and we have a non-zero lot cost, we
    ~     need to calculate the unit cost appropriately.
    var cost as number
    if (@isbuy = 0) then
      cost = field[grCost].value
    elseif (field[grLotCost].value <> 0) then
      cost = field[grLotCost].value / field[lotsize].value
    else
      cost = field[grCost].value
      endif

    ~setup the unit cost for the item
    hero.transact.field[xactEach].value = cost

    ~zero out the cash amount to be paid (implying use of the standard cost)
    hero.transact.field[xactCash].value = 0

    ~if the item is gear, setup whether the item holds other gear
    if (isgear <> 0) then
      hero.transact.field[xactHolder].value = gearcount
      endif
    ]]></procedure>


  <!-- Procedure XactBuy
        Purchase an item for cash from the character's resources.
  -->
  <procedure id="XactBuy" scripttype="xactbuy"><![CDATA[
    ~if we're buying for free, no cash should be touched, so get out
    doneif (hero.transact.field[xactIsFree].value <> 0)

    ~get the cash amount specified by the user
    var cash as number
    cash = hero.transact.field[xactCash].value

    ~if no cash amount was given, get the standard total cost for the purchase
    if (cash = 0) then
      cash = hero.transact.field[xactQty].value * hero.transact.field[xactEach].value
      endif

    ~if we don't have enough cash to make the purchase, reject the transaction
    if (cash > herofield[acCashNet].value) then
      @reject = "You lack sufficient cash to purchase the item."
      done
      endif

    ~subtract the amount from the current pool of cash
    perform hero.usagepool[TotalCash].adjust[-cash]
    ]]></procedure>


  <!-- Procedure XactSell
        Sell an item for cash that gets added to the character's resources.
  -->
  <procedure id="XactSell" scripttype="xactsell"><![CDATA[
    ~get the cash amount specified by the user
    var cash as number
    cash = hero.transact.field[xactCash].value

    ~add the amount to the current pool of cash
    perform hero.usagepool[TotalCash].adjust[cash]
    ]]></procedure>


<!-- ##################
      The following procedures are used by the Dashboard and Tactical Console panels
     ##################
-->


  <!-- Procedure DshName
        Synthesize the actor name for display in the Dashboard/TacCon. As this is
        specified as a "label" script, the script can access special symbols for the
        script type and we can avoid using a variable to return the results. Instead,
        we can write the name directly into the "@text" special symbol for the
        script. The caller can disable the automatic color highlighting of the name
        by setting the "isnocolor" variable. By default, the actor name is colored
        based on whether it is the active actor.

        Inbound parameter:  isnocolor
  -->
  <procedure id="DshName" scripttype="label"><![CDATA[
    var isnocolor as number

    ~unless disabled, if this hero is active or a minion, change the color
    if (isnocolor = 0) then
      if (hero.isactive <> 0) then
        @text &= "{text clractive}"
      elseif (hero.isminion <> 0) then
        @text &= "{text clrauto}"
        endif
      endif

    ~start with the hero name
    if (empty(hero.actorname) <> 0) then
      if (hero.isminion <> 0) then
        @text &= "Unnamed"
      else
        @text &= "Unnamed Character"
        endif
    else
      @text &= hero.actorname
      endif

    ~if this is a minion, append the master's name
    if (hero.isminion <> 0) then
      var mastername as string
      if (empty(hero.master.actorname) <> 0) then
        if (hero.master.isminion <> 0) then
          mastername = "Unnamed"
        else
          mastername = "Unnamed Character"
          endif
      else
        mastername = hero.master.actorname
        endif
      @text &= " (" & mastername & ")"
      endif

    ~if we have minion text, show it after the name unless it's the same as the hero name
    if (hero.isminion <> 0) then
      var result as number
      result = compare(hero.actorname,hero.miniontext)
      if (result <> 0) then
        @text &= " {text clrdisable}(" & hero.miniontext & "){text clrreset}"
        endif
      endif
    ]]></procedure>


  <!-- Procedure DshGear
        Synthesize the actor's full gear info for display in the Dashboard/TacCon.
        The generated text is placed directly into the "@text" special symbol for
        the "mouseinfo" script, so all the caller needs to do is invoke the script
        and be done.
  -->
  <procedure id="DshGear" scripttype="mouseinfo"><![CDATA[
    @text = "{align left}Click to transfer gear from this character to the active character.{br}{br}"
    var gear as string
    gear = hero.geartree[!Helper.NoMove]
    if (empty(gear) <> 0) then
      @text &= "Gear: No transferable gear possessed"
    else
      @text &= "Gear List:{br}" & gear
      endif
    ]]></procedure>


  <!-- Procedure DshSpecial
        Synthesize a report of the actor's various special abilities for display in
        the Dashboard/TacCon. The generated text is placed directly into the "@text"
        special symbol for the "mouseinfo" script, so all the caller needs to do is
        invoke the script and be done.
  -->
  <procedure id="DshSpecial" scripttype="mouseinfo"><![CDATA[
    var final as string
    var name as string
    var source as string

    ~output all items designated for inclusion
    foreach pick in hero where "DashTacCon.Special" sortas SpecInfo
      if (eachpick.field[spcName].isempty = 0) then
        name = eachpick.field[spcName].text
      else
        name = eachpick.field[name].text
        endif
      source = eachpick.tagnames[SpecialTab.?,","]
      if (length(source) = 0) then
        source = "????"
        endif
      final &= source & ": {b}" & name & "{/b}{br}"
      nexteach

    ~if we have no special abilities, output something appropriate
    if (empty(final) <> 0) then
      final = "- No Special Abilities -"
      endif

    @text = "{align left}" & final
    ]]></procedure>


  <!-- Procedure DshRolls
        Synthesize a report of the pertinent rolls for display in the Dashboard/TacCon.
        The generated text is placed directly into the "@text" special symbol for the
        "mouseinfo" script, so all the caller needs to do is invoke the script and be
        done.
  -->
  <procedure id="DshRolls" scripttype="mouseinfo"><![CDATA[
    var final as string
    var roll as string
    foreach pick in hero where "DashTacCon.Rolls"
      if (eachpick.tagis[component.Skill] <> 0) then
        roll = eachpick.field[sklRoll].text & "{text clrsecond}  (" & eachpick.field[trtFinal].text & " + " & eachpick.linkage[attribute].field[name].text & " " & eachpick.linkage[attribute].field[trtFinal].text & "){text clrreset}"
      else
        roll = "????"
        endif
      final &= eachpick.field[name].text & " {b}" & roll & "{/b}{br}"
      nexteach
    @text = "{align left}" & final
    ]]></procedure>


  <!-- Procedure DshCombat
        Synthesize a report of the various combat details (e.g. weapons and armor)
        for display in the Dashboard/TacCon. The generated text is placed directly
        into the "@text" special symbol for the "mouseinfo" script, so all the
        caller needs to do is invoke the script and be done.
  -->
  <procedure id="DshCombat" scripttype="mouseinfo"><![CDATA[
    var ismore as number
    var final as string
    var info as string

    ~output basic combat information
    foreach pick in hero where "DashTacCon.Combat" sortas explicit
      info = eachpick.field[name].text & " {b}" & eachpick.field[trtFinal].text & "{/b}"
      final = splice(final,info,", ")
      nexteach
    final &= "{br}{br}"

    ~output equipped armor and shield
    info = ""
    foreach pick in hero from Armor
      if (eachpick.field[grIsEquip].value <> 0) then
        info &= eachpick.field[name].text & " {b}" & eachpick.field[defDefense].text & "{/b}{br}"
        endif
      nexteach
    if (empty(info) <> 0) then
      info = "-No Armor Equipped-{br}"
      endif
    final &= info
    info = ""
    foreach pick in hero from Shield
      if (eachpick.field[grIsEquip].value <> 0) then
        info &= eachpick.field[name].text & " {b}" & eachpick.field[defDefense].text & "{/b}{br}"
        endif
      nexteach
    if (empty(info) <> 0) then
      info = "-No Shield Equipped-{br}"
      endif
    final &= info & "{br}"

    ~output all weapons, with equipped ones first
    info = ""
    foreach pick in hero from WeaponBase sortas Armory
      info &= eachpick.field[name].text & " {b}" & eachpick.field[wpNetAtk].text & " {/b}{text clrsecond}@{text clrreset}" & eachpick.field[wpDamage].text & "{br}"
      nexteach
    if (empty(info) <> 0) then
      info = "-No Weapons-{br}"
      endif
    final &= info

    @text = "{align left}" & final
    ]]></procedure>


  <!-- Procedure DshBasics
        Synthesize a report of the various character basic details for display in
        the Dashboard/TacCon. The generated text is placed directly into the "@text"
        special symbol for the "mouseinfo" script, so all the caller needs to do is
        invoke the script and be done.
  -->
  <procedure id="DshBasics" scripttype="mouseinfo"><![CDATA[
    var final as string
    var info as string

    ~output our race
    info = hero.findchild[Archetype].field[name].text
    if (empty(info) <> 0) then
      info = "-none-"
      endif
    final = "Species: {b}" & info & "{/b}{br}{br}"

    ~output our power point pool
    ~perform hero.child[trPowerPts].setfocus
    ~final &= "Power Points: {b}" & focus.field[trtFinal].text & " / " & focus.field[trtMaximum].text & "{/b}{br}{br}"

    ~output our resistance traits
    ~foreach pick in hero where "User.Resistance"
    ~  final &= eachpick.field[name].text & ": {b}" & eachpick.field[trtFinal].text & "{/b}{br}"
    ~  nexteach
    ~final &= "{br}"

    ~output attributes
    foreach pick in hero from Attribute
      final &= eachpick.field[name].text & ": {b}" & eachpick.field[trtFinal].text & "{/b}{br}"
      nexteach

    ~output any permanent adjustments
    info = ""
    foreach pick in hero where "InPlay.Permanent"
      info &= eachpick.field[adjName].text & "{br}"
      nexteach
    if (empty(info) = 0) then
      info = "{br}{b}Permanent Adjustments:{/b}{br}" & info
      endif
    final &= info

    ~return the final text
    @text = "{align left}" & final
    ]]></procedure>


  <!-- Procedure DshActive
        Synthesize a report of the character's activated abilities for display in
        the Dashboard/TacCon. The generated text is placed directly into the "@text"
        special symbol for the "mouseinfo" script, so all the caller needs to do is
        invoke the script and be done.
  -->
  <procedure id="DshActive" scripttype="mouseinfo"><![CDATA[
    ~if there are no activated abilities for the character, report that fact
    if (hero.tagis[Activated.?] = 0) then
      if (herofield[tactNotes].isempty <> 0) then
        @text = "No abilities are active."
        done
        endif
      endif

    ~output all activated abilities and conditions for the character (if any)
    var final as string
    if (hero.tagis[Activated.?] <> 0) then
      final = "{b}Activated Abilities:{/b}"
      foreach pick in hero where "(Adjustment.? | Helper.Activated) & !InPlay.Permanent"
        final &= "{br}"
        if (eachpick.tagis[Adjustment.?] <> 0) then
          final &= eachpick.field[adjName].text
        else
          final &= eachpick.field[name].text
          endif
        nexteach
      endif

    ~append any tactical console notes at the end
    if (herofield[tactNotes].isempty = 0) then
      if (empty(final) = 0) then
        final &= "{br}{br}"
        endif
      final &= "{b}Tactical Notes:{/b}{br}" & herofield[tactNotes].text
      endif

    @text = "{align left}" & final
    ]]></procedure>


<!-- ##################
      The following procedures are used in conjunction with printed output
     ##################
-->


  <!-- Procedure JrnInfo
        Synthesize a journal entry for detailed output. The generated text is
        placed in the "infotext" variable. If special spacing needs to be inserted
        between sections of the output, the caller can dictate that via the
        "spacing" variable.

        Inbound parameter:  spacing
        Outbound parameter: infotext
  -->
  <procedure id="JrnInfo" context="info"><![CDATA[
    ~declare variables that are used to communicate with our caller
    var spacing as string
    var infotext as string

    ~start with left-aligned text and append the date and award details
    infotext = "{align left}"
    if (field[jrnGame].value <> 0) then
      infotext = infotext & "{b}Date (game world){/b}: " & field[jrnGame].datetime[gamedate,"/"] & "{br}"
      endif
    infotext = infotext & "{b}Date (real world){/b}: " & field[jrnReal].datetime[realdate,"/"] & "{br}" & spacing
    infotext = infotext & "{b}XP Awarded{/b}: " & usagepool[JrnlXP].value & "{br}"
    infotext = infotext & "{b}Cash Awarded{/b}: " & usagepool[JrnlCash].value & "{br}"
    infotext = infotext & spacing
    ]]></procedure>

  <!-- Script used to set up AoE selection   -->

  <procedure id="CalcXPForTrait" context="pick"><![CDATA[
    ~set up our tag expression for selecting appropriate specialty
	var compType as string
	var rankVal as number
	var freeRank as number
	var minVal as number
	var XPVal as number

    var totRank as number
	var XPadj as number
	
    if (compare(compType,"Attribute") = 0) then
      if (rankVal > minVal) then
        if (rankVal >= 2) then 
          if (minVal < 2) then
              XPVal += 20
          endif
        endif
        
        if (rankVal >= 3) then
          if (minVal < 3) then
            XPVal += 30
          endif
        endif
        
        if (rankVal >= 4) then
          if (minVal < 4) then
            XPVal += 40
          endif
        endif
        
        if (rankVal >= 5) then
          if (minVal < 5) then
            XPVal += 50
          endif
        endif
        
        if (rankVal = 6) then
          if (minVal < 6) then
            XPVal += 60
          endif
        endif
	  endif
	elseif (compare(compType,"Skill") = 0) then
	  totRank = rankVal + freeRank
	  
	  if (totRank > minVal) then
        if (totRank >= 1) then 
          XPVal += 5
		  if (freeRank >= 1) then
            XPadj += 5
			endif
        endif
        
        if (totRank >= 2) then 
          XPVal += 10
		  if (freeRank >= 2) then
            XPadj += 10
			endif
        endif
        
        if (totRank >= 3) then
          XPVal += 15
		  if (freeRank >= 3) then
            XPadj += 15
			endif
        endif
        
        if (totRank >= 4) then
          XPVal += 20
		  if (freeRank >= 4) then
            XPadj += 20
			endif
        endif
        
        if (totRank >= 5) then
          XPVal += 25
		  if (freeRank >= 5) then
            XPadj += 25
			endif
        endif
        
        if (totRank = 6) then
          XPVal += 30
		  if (freeRank = 6) then
            XPadj += 30
			endif
        endif
		  
        if (tagis[SkillType.CareerSkill] = 0) then
          XPVal += (5 * rankVal) 
        endif
		
		~ remove free rank XP
		if (freeRank > 0) then
		  XPVal -= XPadj
		  endif
		  
      endif
    endif	  

    hero.child[resXP].field[resSpent].value += XPVal
	
    ]]></procedure>

  <procedure id="InfoMods" context="info"><![CDATA[
    ~declare variables that are used to communicate with our caller
    var iteminfo as string
	
	var modList as string
	
    if (field[grHardpoints].value <> 0) then 
      iteminfo &= "Hardpoints (Used / Max): " & field[grHardpointsUsed].text & " / " & field[grHardpoints].text & "{br}"
	  iteminfo &= "Modifications: " 
	  
	  foreach pick in gizmo from ItemMod where "!ItemMod.ItemModHelper"
	    modList = splice(modList,eachpick.field[name].text,", ")
	    nexteach
      
	  if (empty(modList) <> 0) then
        iteminfo &= "None"
	  else 
	    iteminfo &= modList
        endif
		
      endif
	
    iteminfo &= "{br}"

    ]]></procedure>
	
  <procedure id="SetItemModExpr" context="pick"><![CDATA[
    ~make sure there's a gizmo to travel to
    doneif (isgizmo = 0)
    
    ~set up our tag expression for selecting appropriate Traits
    var expr as string
    var myId as string

    expr = "!thingid.ItemModHelper"

    gizmo.childfound[ItemModHelper].field[imhExpr].text = expr
	
    ]]></procedure>

  <!-- BuildSymDice - process added values from Skill/Gear to create
                      the extra string of added bonus symbols/dice
                      due to Qualities, etc.					  
					  -->
  <procedure id="BuildSymDice" context="pick"><![CDATA[
    ~set up our variables that are used to communicate with our caller
	var adj as number
    var adjBoost as number
    var adjSetback as number
    var adjSuccess as number
    var adjFailure as number
    var adjAdvantage as number
    var adjDifficulty as number
	
    var sdText as string
	var sdColor as string
	var sdGraphic as string


    ~ Dice 	  
    ~ Boosts
	adj = 0
	adj = adjBoost
	if (adj <> 0) then
	  if (adj < 0) then
	    while (adj <> 0)
 		  sdText &= "-B"
 		  sdColor &= "{text 87CEEB}-B{text ffffff}"
		  sdGraphic &= "{bmp die_boostminus}"
		  adj += 1
		  loop
	  else
		while (adj <> 0)
		  sdText &= "B"
		  sdColor &= "{text 87CEEB}B{text ffffff}"
		  sdGraphic &= "{bmp die_boost}"
		  adj -= 1
	    loop
	      endif
		    
	  endif
	  
    ~ Setbacks
	adj = 0
	adj = adjSetback
	~ notify "Setbacks: " & adj
	if (adj <> 0) then
	  if (adj < 0) then
	    while (adj <> 0)
 		  sdText &= "-SB"
 		  sdColor &= "{text ffffff}-SB{text ffffff}"
		  sdGraphic &= "{bmp die_setbackminus}"
		  adj += 1
		  loop
	  else
		while (adj <> 0)
		  sdText &= "+SB"
		  sdColor &= "{back ffffff}{text 000000}+SB{text ffffff}{revert}"
		  sdGraphic &= "{bmp die_setback}"
		  adj -= 1
	      loop
	    endif
		    
	  endif
	 
    ~ Difficulty
	adj = 0
	adj = adjDifficulty
	~ notify "Difficulties: " & adj
	if (adj <> 0) then
	  if (adj < 0) then
	    while (adj <> 0)
 		  sdText &= "-D"
 		  sdColor &= "{text 8E44AD}-D{text ffffff}"
		  sdGraphic &= "{bmp die_difficultyminus}"
		  adj += 1
		  loop
	  else
		while (adj <> 0)
		  sdText &= "+D"
		  sdColor &= "{text 8E44AD}+D{text ffffff}"
		  sdGraphic &= "{bmp die_difficulty}"
		  adj -= 1
	      loop
	    endif
		    
	  endif
	  
    ~ Symbols    
    ~ Successes
	adj = 0
	adj = adjSuccess
	if (adj <> 0) then
	  if (adj < 0) then
	    while (adj <> 0)
 		  sdText &= "-S"
 		  sdColor &= "{text 000000}-S{text ffffff}"
		  sdGraphic &= "{bmp sym_successminus}"
		  adj += 1
		  loop
	  else
		while (adj <> 0)
 		  sdText &= "+S"
 		  sdColor &= "{text 000000}+S{text ffffff}"
		  sdGraphic &= "{bmp sym_success}"
		  adj -= 1
	    loop
	      endif
		    
	  endif
	  
    ~ Advantages
	adj = 0
	adj = adjAdvantage
	if (adj <> 0) then
	  if (adj < 0) then
	    while (adj <> 0)
 		  sdText &= "-A"
 		  sdColor &= "{back ffffff}{text 000000}-A{text ffffff}{revert}"
		  sdGraphic &= "{bmp sym_advantageminus}"
		  adj += 1
		  loop
	  else
		while (adj <> 0)
 		  sdText &= "+A"
 		  sdColor &= "{back ffffff}{text 000000}+A{text ffffff}{revert}"
		  sdGraphic &= "{bmp sym_advantage}"
		  adj -= 1
	    loop
	      endif
		    
	  endif 
	  
    ~ Failures
	adj = 0
	adj = adjFailure
	if (adj <> 0) then
	  if (adj < 0) then
	    while (adj <> 0)
 		  sdText &= "-F"
 		  sdColor &= "{text 000000}-F{text ffffff}"
		  sdGraphic &= "{bmp sym_failureminus}"
		  adj += 1
		  loop
	  else
		while (adj <> 0)
 		  sdText &= "+F"
 		  sdColor &= "{text 000000}+F{text ffffff}"
		  sdGraphic &= "{bmp sym_failure}"
		  adj -= 1
	    loop
	      endif
		    
	  endif
	
	
    ]]></procedure>    
  </document>
